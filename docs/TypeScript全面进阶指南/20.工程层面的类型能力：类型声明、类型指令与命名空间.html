<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>20.工程层面的类型能力：类型声明、类型指令与命名空间 | 博客首页</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blogs/avatar.ico">
    <meta name="description" content="Vimalakirti blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blogs/assets/css/0.styles.8ee0588d.css" as="style"><link rel="preload" href="/blogs/assets/js/app.500cfb4c.js" as="script"><link rel="preload" href="/blogs/assets/js/3.ab704d4e.js" as="script"><link rel="preload" href="/blogs/assets/js/1.120dd0c6.js" as="script"><link rel="preload" href="/blogs/assets/js/127.7f484897.js" as="script"><link rel="preload" href="/blogs/assets/js/15.a0d3f198.js" as="script"><link rel="prefetch" href="/blogs/assets/js/10.22997040.js"><link rel="prefetch" href="/blogs/assets/js/100.fd6dfd82.js"><link rel="prefetch" href="/blogs/assets/js/101.137866a8.js"><link rel="prefetch" href="/blogs/assets/js/102.8e97ff4c.js"><link rel="prefetch" href="/blogs/assets/js/103.cd97319e.js"><link rel="prefetch" href="/blogs/assets/js/104.0e7eed5a.js"><link rel="prefetch" href="/blogs/assets/js/105.35566707.js"><link rel="prefetch" href="/blogs/assets/js/106.f0f9b63e.js"><link rel="prefetch" href="/blogs/assets/js/107.751e7979.js"><link rel="prefetch" href="/blogs/assets/js/108.244161be.js"><link rel="prefetch" href="/blogs/assets/js/109.8ba67618.js"><link rel="prefetch" href="/blogs/assets/js/11.123cec5f.js"><link rel="prefetch" href="/blogs/assets/js/110.a85d3a98.js"><link rel="prefetch" href="/blogs/assets/js/111.79b978e1.js"><link rel="prefetch" href="/blogs/assets/js/112.e136754e.js"><link rel="prefetch" href="/blogs/assets/js/113.9872522c.js"><link rel="prefetch" href="/blogs/assets/js/114.e50bf446.js"><link rel="prefetch" href="/blogs/assets/js/115.94e4f425.js"><link rel="prefetch" href="/blogs/assets/js/116.154333be.js"><link rel="prefetch" href="/blogs/assets/js/117.713f2f2e.js"><link rel="prefetch" href="/blogs/assets/js/118.5f2b2811.js"><link rel="prefetch" href="/blogs/assets/js/119.8d4ac096.js"><link rel="prefetch" href="/blogs/assets/js/12.b2660b05.js"><link rel="prefetch" href="/blogs/assets/js/120.04f64197.js"><link rel="prefetch" href="/blogs/assets/js/121.ca17861d.js"><link rel="prefetch" href="/blogs/assets/js/122.6e7d28fb.js"><link rel="prefetch" href="/blogs/assets/js/123.f7b5977c.js"><link rel="prefetch" href="/blogs/assets/js/124.213e4532.js"><link rel="prefetch" href="/blogs/assets/js/125.3fa29b40.js"><link rel="prefetch" href="/blogs/assets/js/126.a4039525.js"><link rel="prefetch" href="/blogs/assets/js/128.fdc975c7.js"><link rel="prefetch" href="/blogs/assets/js/129.fe2abf96.js"><link rel="prefetch" href="/blogs/assets/js/13.27388741.js"><link rel="prefetch" href="/blogs/assets/js/130.7a2140c1.js"><link rel="prefetch" href="/blogs/assets/js/131.425f7c16.js"><link rel="prefetch" href="/blogs/assets/js/132.70567358.js"><link rel="prefetch" href="/blogs/assets/js/133.fbc58b05.js"><link rel="prefetch" href="/blogs/assets/js/134.dcc7d0ce.js"><link rel="prefetch" href="/blogs/assets/js/135.1141e9a6.js"><link rel="prefetch" href="/blogs/assets/js/136.99a04b7a.js"><link rel="prefetch" href="/blogs/assets/js/137.7e4c228d.js"><link rel="prefetch" href="/blogs/assets/js/138.3a987474.js"><link rel="prefetch" href="/blogs/assets/js/139.c970c8e9.js"><link rel="prefetch" href="/blogs/assets/js/14.3bb072f4.js"><link rel="prefetch" href="/blogs/assets/js/140.8a4a896e.js"><link rel="prefetch" href="/blogs/assets/js/141.6945715d.js"><link rel="prefetch" href="/blogs/assets/js/142.25a947bd.js"><link rel="prefetch" href="/blogs/assets/js/143.bbe141ba.js"><link rel="prefetch" href="/blogs/assets/js/144.07143997.js"><link rel="prefetch" href="/blogs/assets/js/145.9a9c230c.js"><link rel="prefetch" href="/blogs/assets/js/146.ff058b45.js"><link rel="prefetch" href="/blogs/assets/js/147.611b1a61.js"><link rel="prefetch" href="/blogs/assets/js/148.c4db457d.js"><link rel="prefetch" href="/blogs/assets/js/149.e84e7c9e.js"><link rel="prefetch" href="/blogs/assets/js/150.26165aef.js"><link rel="prefetch" href="/blogs/assets/js/151.bbc21f18.js"><link rel="prefetch" href="/blogs/assets/js/152.72161a54.js"><link rel="prefetch" href="/blogs/assets/js/153.e1641b61.js"><link rel="prefetch" href="/blogs/assets/js/154.e91db58a.js"><link rel="prefetch" href="/blogs/assets/js/155.887f2853.js"><link rel="prefetch" href="/blogs/assets/js/156.b22cfc20.js"><link rel="prefetch" href="/blogs/assets/js/157.63f68b5b.js"><link rel="prefetch" href="/blogs/assets/js/158.856832c1.js"><link rel="prefetch" href="/blogs/assets/js/159.92584876.js"><link rel="prefetch" href="/blogs/assets/js/16.6e74b879.js"><link rel="prefetch" href="/blogs/assets/js/160.1d21558a.js"><link rel="prefetch" href="/blogs/assets/js/161.bb564e9f.js"><link rel="prefetch" href="/blogs/assets/js/162.caec4409.js"><link rel="prefetch" href="/blogs/assets/js/163.c6f64985.js"><link rel="prefetch" href="/blogs/assets/js/164.66e928ae.js"><link rel="prefetch" href="/blogs/assets/js/165.e3cb517b.js"><link rel="prefetch" href="/blogs/assets/js/166.e7fd38f0.js"><link rel="prefetch" href="/blogs/assets/js/167.0817b0a0.js"><link rel="prefetch" href="/blogs/assets/js/168.11c5a1b6.js"><link rel="prefetch" href="/blogs/assets/js/169.617f3bc0.js"><link rel="prefetch" href="/blogs/assets/js/17.3a3181e0.js"><link rel="prefetch" href="/blogs/assets/js/170.e2da6722.js"><link rel="prefetch" href="/blogs/assets/js/171.e8b33425.js"><link rel="prefetch" href="/blogs/assets/js/172.bded7304.js"><link rel="prefetch" href="/blogs/assets/js/173.c6aef283.js"><link rel="prefetch" href="/blogs/assets/js/174.61c0e632.js"><link rel="prefetch" href="/blogs/assets/js/175.81e803dc.js"><link rel="prefetch" href="/blogs/assets/js/176.239f927c.js"><link rel="prefetch" href="/blogs/assets/js/177.a4edfa3f.js"><link rel="prefetch" href="/blogs/assets/js/178.bef8fd54.js"><link rel="prefetch" href="/blogs/assets/js/179.b745b5db.js"><link rel="prefetch" href="/blogs/assets/js/18.fdfdabaf.js"><link rel="prefetch" href="/blogs/assets/js/180.1e6a265e.js"><link rel="prefetch" href="/blogs/assets/js/181.62663a80.js"><link rel="prefetch" href="/blogs/assets/js/182.58a29b9c.js"><link rel="prefetch" href="/blogs/assets/js/183.ae3152e7.js"><link rel="prefetch" href="/blogs/assets/js/184.83530a9e.js"><link rel="prefetch" href="/blogs/assets/js/185.8a5f69a9.js"><link rel="prefetch" href="/blogs/assets/js/186.d3e57211.js"><link rel="prefetch" href="/blogs/assets/js/187.566cbf78.js"><link rel="prefetch" href="/blogs/assets/js/188.01bc9809.js"><link rel="prefetch" href="/blogs/assets/js/189.0a7925a0.js"><link rel="prefetch" href="/blogs/assets/js/19.4238119d.js"><link rel="prefetch" href="/blogs/assets/js/190.d40196a9.js"><link rel="prefetch" href="/blogs/assets/js/191.e26da653.js"><link rel="prefetch" href="/blogs/assets/js/192.89da53bc.js"><link rel="prefetch" href="/blogs/assets/js/193.8fce4546.js"><link rel="prefetch" href="/blogs/assets/js/194.156d0532.js"><link rel="prefetch" href="/blogs/assets/js/195.bfc310d0.js"><link rel="prefetch" href="/blogs/assets/js/196.918c289c.js"><link rel="prefetch" href="/blogs/assets/js/197.f1facd93.js"><link rel="prefetch" href="/blogs/assets/js/198.9bb0334e.js"><link rel="prefetch" href="/blogs/assets/js/199.6003905b.js"><link rel="prefetch" href="/blogs/assets/js/20.07ce6e0b.js"><link rel="prefetch" href="/blogs/assets/js/200.3a254968.js"><link rel="prefetch" href="/blogs/assets/js/201.0069edba.js"><link rel="prefetch" href="/blogs/assets/js/202.e8c89894.js"><link rel="prefetch" href="/blogs/assets/js/203.5a8a01ee.js"><link rel="prefetch" href="/blogs/assets/js/204.0d214ba2.js"><link rel="prefetch" href="/blogs/assets/js/205.00ca5934.js"><link rel="prefetch" href="/blogs/assets/js/206.f397a1ec.js"><link rel="prefetch" href="/blogs/assets/js/207.fb5b45fd.js"><link rel="prefetch" href="/blogs/assets/js/208.63155633.js"><link rel="prefetch" href="/blogs/assets/js/209.2ed6ecc2.js"><link rel="prefetch" href="/blogs/assets/js/21.089865dd.js"><link rel="prefetch" href="/blogs/assets/js/210.cbc16c4b.js"><link rel="prefetch" href="/blogs/assets/js/211.3061bbff.js"><link rel="prefetch" href="/blogs/assets/js/212.ffb1aa5d.js"><link rel="prefetch" href="/blogs/assets/js/213.f5e03609.js"><link rel="prefetch" href="/blogs/assets/js/22.12d8fc10.js"><link rel="prefetch" href="/blogs/assets/js/23.02f8a3dc.js"><link rel="prefetch" href="/blogs/assets/js/24.84bc157e.js"><link rel="prefetch" href="/blogs/assets/js/25.9b49dd25.js"><link rel="prefetch" href="/blogs/assets/js/26.e8ffd492.js"><link rel="prefetch" href="/blogs/assets/js/27.73ccf8d1.js"><link rel="prefetch" href="/blogs/assets/js/28.b6ff0a49.js"><link rel="prefetch" href="/blogs/assets/js/29.ba8c9cd7.js"><link rel="prefetch" href="/blogs/assets/js/30.ed151282.js"><link rel="prefetch" href="/blogs/assets/js/31.ee5a9adc.js"><link rel="prefetch" href="/blogs/assets/js/32.c4d7f55d.js"><link rel="prefetch" href="/blogs/assets/js/33.455ab698.js"><link rel="prefetch" href="/blogs/assets/js/34.3dc6fd97.js"><link rel="prefetch" href="/blogs/assets/js/35.cef5a85f.js"><link rel="prefetch" href="/blogs/assets/js/36.157cb55a.js"><link rel="prefetch" href="/blogs/assets/js/37.7786986a.js"><link rel="prefetch" href="/blogs/assets/js/38.ace12f85.js"><link rel="prefetch" href="/blogs/assets/js/39.2680a1d9.js"><link rel="prefetch" href="/blogs/assets/js/4.4c5b9874.js"><link rel="prefetch" href="/blogs/assets/js/40.cfe4df2f.js"><link rel="prefetch" href="/blogs/assets/js/41.7f0d36a7.js"><link rel="prefetch" href="/blogs/assets/js/42.20cb24f9.js"><link rel="prefetch" href="/blogs/assets/js/43.5cda41ae.js"><link rel="prefetch" href="/blogs/assets/js/44.6dd13984.js"><link rel="prefetch" href="/blogs/assets/js/45.108e8bf0.js"><link rel="prefetch" href="/blogs/assets/js/46.0a58d921.js"><link rel="prefetch" href="/blogs/assets/js/47.fc236d73.js"><link rel="prefetch" href="/blogs/assets/js/48.937eaaa0.js"><link rel="prefetch" href="/blogs/assets/js/49.e3384d83.js"><link rel="prefetch" href="/blogs/assets/js/5.d80bb541.js"><link rel="prefetch" href="/blogs/assets/js/50.45a095ef.js"><link rel="prefetch" href="/blogs/assets/js/51.39c8338e.js"><link rel="prefetch" href="/blogs/assets/js/52.efd2112f.js"><link rel="prefetch" href="/blogs/assets/js/53.267c64b0.js"><link rel="prefetch" href="/blogs/assets/js/54.b5b820d2.js"><link rel="prefetch" href="/blogs/assets/js/55.0ef4f037.js"><link rel="prefetch" href="/blogs/assets/js/56.8f5851ca.js"><link rel="prefetch" href="/blogs/assets/js/57.05fdaea6.js"><link rel="prefetch" href="/blogs/assets/js/58.ab6ba5e2.js"><link rel="prefetch" href="/blogs/assets/js/59.d8573084.js"><link rel="prefetch" href="/blogs/assets/js/6.a288fb54.js"><link rel="prefetch" href="/blogs/assets/js/60.1b462558.js"><link rel="prefetch" href="/blogs/assets/js/61.4128f601.js"><link rel="prefetch" href="/blogs/assets/js/62.88a7491d.js"><link rel="prefetch" href="/blogs/assets/js/63.4461d91d.js"><link rel="prefetch" href="/blogs/assets/js/64.38ea9196.js"><link rel="prefetch" href="/blogs/assets/js/65.fd87f9fe.js"><link rel="prefetch" href="/blogs/assets/js/66.e5d09ccb.js"><link rel="prefetch" href="/blogs/assets/js/67.22554b65.js"><link rel="prefetch" href="/blogs/assets/js/68.0502589c.js"><link rel="prefetch" href="/blogs/assets/js/69.35937916.js"><link rel="prefetch" href="/blogs/assets/js/7.ed923a16.js"><link rel="prefetch" href="/blogs/assets/js/70.7e3deaae.js"><link rel="prefetch" href="/blogs/assets/js/71.46a84170.js"><link rel="prefetch" href="/blogs/assets/js/72.61136659.js"><link rel="prefetch" href="/blogs/assets/js/73.2202ef65.js"><link rel="prefetch" href="/blogs/assets/js/74.b9d82b76.js"><link rel="prefetch" href="/blogs/assets/js/75.206dca9b.js"><link rel="prefetch" href="/blogs/assets/js/76.4ca6fb0e.js"><link rel="prefetch" href="/blogs/assets/js/77.7f16f66d.js"><link rel="prefetch" href="/blogs/assets/js/78.3563bf98.js"><link rel="prefetch" href="/blogs/assets/js/79.bc63c39e.js"><link rel="prefetch" href="/blogs/assets/js/8.e6004ff9.js"><link rel="prefetch" href="/blogs/assets/js/80.77fe98fc.js"><link rel="prefetch" href="/blogs/assets/js/81.e72bbb3b.js"><link rel="prefetch" href="/blogs/assets/js/82.3221aa1f.js"><link rel="prefetch" href="/blogs/assets/js/83.a9574403.js"><link rel="prefetch" href="/blogs/assets/js/84.5b77709e.js"><link rel="prefetch" href="/blogs/assets/js/85.6ab70366.js"><link rel="prefetch" href="/blogs/assets/js/86.86e90588.js"><link rel="prefetch" href="/blogs/assets/js/87.6c30aaeb.js"><link rel="prefetch" href="/blogs/assets/js/88.91ed30aa.js"><link rel="prefetch" href="/blogs/assets/js/89.78360293.js"><link rel="prefetch" href="/blogs/assets/js/9.8e018535.js"><link rel="prefetch" href="/blogs/assets/js/90.77b1bca0.js"><link rel="prefetch" href="/blogs/assets/js/91.4376e5c4.js"><link rel="prefetch" href="/blogs/assets/js/92.12c60706.js"><link rel="prefetch" href="/blogs/assets/js/93.7e733384.js"><link rel="prefetch" href="/blogs/assets/js/94.f943c59f.js"><link rel="prefetch" href="/blogs/assets/js/95.35646351.js"><link rel="prefetch" href="/blogs/assets/js/96.869251c0.js"><link rel="prefetch" href="/blogs/assets/js/97.e12beed8.js"><link rel="prefetch" href="/blogs/assets/js/98.35e82b36.js"><link rel="prefetch" href="/blogs/assets/js/99.b683092f.js">
    <link rel="stylesheet" href="/blogs/assets/css/0.styles.8ee0588d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>博客首页</h3> <p class="description" data-v-59e6cb88>Vimalakirti blog</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>呛再首</span>
          
        <span data-v-59e6cb88>2019 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blogs/" class="home-link router-link-active"><img src="/blogs/avatar.jpg" alt="博客首页" class="logo"> <span class="site-name">博客首页</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/css/" class="nav-link"><i class="undefined"></i>
  css
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/html/" class="nav-link"><i class="undefined"></i>
  html
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/其他/" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/React/" class="nav-link"><i class="undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/杂记/" class="nav-link"><i class="undefined"></i>
  杂记
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/Typescript/" class="nav-link"><i class="undefined"></i>
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blogs/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/docs/HTML-Library/" class="nav-link"><i class="undefined"></i>
  HTML-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/CSS-Library/" class="nav-link"><i class="undefined"></i>
  CSS-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Javascript-Library/" class="nav-link"><i class="undefined"></i>
  Javascript-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Vue-Library/" class="nav-link"><i class="undefined"></i>
  Vue-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/React-Library/" class="nav-link"><i class="undefined"></i>
  React-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Other-Library/" class="nav-link"><i class="undefined"></i>
  Other-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/juejin/" class="nav-link"><i class="undefined"></i>
  juejin
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/interview/" class="nav-link"><i class="undefined"></i>
  web-interview
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/前端性能优化与实践/" class="nav-link"><i class="undefined"></i>
  前端性能优化与实践
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/使用webpack定制前端开发环境/" class="nav-link"><i class="undefined"></i>
  使用webpack定制前端开发环境
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/TypeScript全面进阶指南/" class="nav-link"><i class="undefined"></i>
  TypeScript全面进阶指南
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Vimalate" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/blogs/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    呛再首
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>187</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>20</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/blogs/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/categories/css/" class="nav-link"><i class="undefined"></i>
  css
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/html/" class="nav-link"><i class="undefined"></i>
  html
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/javascript/" class="nav-link"><i class="undefined"></i>
  javascript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/其他/" class="nav-link"><i class="undefined"></i>
  其他
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/React/" class="nav-link"><i class="undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/杂记/" class="nav-link"><i class="undefined"></i>
  杂记
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/Typescript/" class="nav-link"><i class="undefined"></i>
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/blogs/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li></ul></div></div><div class="nav-item"><a href="/blogs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blogs/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blogs/docs/HTML-Library/" class="nav-link"><i class="undefined"></i>
  HTML-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/CSS-Library/" class="nav-link"><i class="undefined"></i>
  CSS-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Javascript-Library/" class="nav-link"><i class="undefined"></i>
  Javascript-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Vue-Library/" class="nav-link"><i class="undefined"></i>
  Vue-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/React-Library/" class="nav-link"><i class="undefined"></i>
  React-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/Other-Library/" class="nav-link"><i class="undefined"></i>
  Other-Library
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/juejin/" class="nav-link"><i class="undefined"></i>
  juejin
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/interview/" class="nav-link"><i class="undefined"></i>
  web-interview
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/前端性能优化与实践/" class="nav-link"><i class="undefined"></i>
  前端性能优化与实践
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/使用webpack定制前端开发环境/" class="nav-link"><i class="undefined"></i>
  使用webpack定制前端开发环境
</a></li><li class="dropdown-item"><!----> <a href="/blogs/docs/TypeScript全面进阶指南/" class="nav-link"><i class="undefined"></i>
  TypeScript全面进阶指南
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/Vimalate" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/blogs/docs/TypeScript%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" aria-current="page" class="sidebar-link">TypeScript全面进阶指南</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/1.开篇：用正确的方式学习 TypeScript.html" class="sidebar-link">1.开篇：用正确的方式学习 TypeScript</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/2.工欲善其事：打造最舒适的 TypeScript 开发环境.html" class="sidebar-link">2.工欲善其事：打造最舒适的 TypeScript 开发环境</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/3.进入类型的世界：理解原始类型与对象类型.html" class="sidebar-link">3.进入类型的世界：理解原始类型与对象类型</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/4.掌握字面量类型与枚举，让你的类型再精确一些.html" class="sidebar-link">4.掌握字面量类型与枚举，让你的类型再精确一些</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/5.函数与 Class 中的类型：详解函数重载与面向对象.html" class="sidebar-link">5.函数与 Class 中的类型：详解函数重载与面向对象</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/6.探秘内置类型：any、unknown、never 与类型断言.html" class="sidebar-link">6.探秘内置类型：any、unknown、never 与类型断言</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/7.类型编程好帮手：TypeScript 类型工具（上）.html" class="sidebar-link">7.类型编程好帮手：TypeScript 类型工具（上）</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/8.类型编程好帮手：TypeScript 类型工具（下）.html" class="sidebar-link">8.类型编程好帮手：TypeScript 类型工具（下）</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/9.类型编程基石：TypeScript 中无处不在的泛型.html" class="sidebar-link">9.类型编程基石：TypeScript 中无处不在的泛型</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/10.结构化类型系统：类型兼容性判断的幕后.html" class="sidebar-link">10.结构化类型系统：类型兼容性判断的幕后</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/11.类型系统层级：从 Top Type 到 Bottom Type.html" class="sidebar-link">11.类型系统层级：从 Top Type 到 Bottom Type</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/12.类型里的逻辑运算：条件类型与 infer.html" class="sidebar-link">12.类型里的逻辑运算：条件类型与 infer</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/13.内置工具类型基础：别再妖魔化工具类型了！.html" class="sidebar-link">13.内置工具类型基础：别再妖魔化工具类型了！</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/14.反方向类型推导：用好上下文相关类型.html" class="sidebar-link">14.反方向类型推导：用好上下文相关类型</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/15.数类型：协变与逆变的比较.html" class="sidebar-link">15.数类型：协变与逆变的比较</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/16.了解类型编程与类型体操的意义，找到平衡点.html" class="sidebar-link">16.了解类型编程与类型体操的意义，找到平衡点</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/17.内置工具类型进阶：类型编程进阶.html" class="sidebar-link">17.内置工具类型进阶：类型编程进阶</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/18.基础类型新成员：模板字符串类型入门.html" class="sidebar-link">18.基础类型新成员：模板字符串类型入门</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/19.类型编程新范式：模板字符串工具类型进阶.html" class="sidebar-link">19.类型编程新范式：模板字符串工具类型进阶</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/20.工程层面的类型能力：类型声明、类型指令与命名空间.html" class="active sidebar-link">20.工程层面的类型能力：类型声明、类型指令与命名空间</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html" class="sidebar-link">21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html" class="sidebar-link">22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/23.全链路 TypeScript 工具库，找到适合你的工具.html" class="sidebar-link">23.全链路 TypeScript 工具库，找到适合你的工具</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html" class="sidebar-link">24.说说 TypeScript 和 ECMAScript 之间那些事儿</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/25.装饰器与反射元数据：了解装饰器基本原理与应用.html" class="sidebar-link">25.装饰器与反射元数据：了解装饰器基本原理与应用</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html" class="sidebar-link">26.控制反转与依赖注入：基于装饰器的依赖注入实现</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/27.TSConfig 全解（上）：构建相关配置.html" class="sidebar-link">27.TSConfig 全解（上）：构建相关配置</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/28.TSConfig 全解（下）：检查相关、工程相关配置.html" class="sidebar-link">28.TSConfig 全解（下）：检查相关、工程相关配置</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html" class="sidebar-link">29.基于 Prisma + NestJs 的 Node API ：前置知识储备</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html" class="sidebar-link">30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html" class="sidebar-link">31.玩转 TypeScript AST：AST Checker 与 CodeMod</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/32.感谢相伴：是结束，也是开始.html" class="sidebar-link">32.感谢相伴：是结束，也是开始</a></li><li><a href="/blogs/docs/TypeScript全面进阶指南/33.漫谈篇：面试中的 TypeScript.html" class="sidebar-link">33.漫谈篇：面试中的 TypeScript</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>20.工程层面的类型能力：类型声明、类型指令与命名空间</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>呛再首</span>
          
        <span data-v-59e6cb88>2019 - </span>
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">20.工程层面的类型能力：类型声明、类型指令与命名空间</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>呛再首</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>10/9/2023</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><p>我们已经结束了 TypeScript 类型能力的学习，这一节将进入 TypeScript 的实战应用篇。实战篇主要包括了工程能力、框架集成、ECMAScript 语法、TSConfig 解析以及 Node API 开发这五个部分。</p> <p>在这一节，我们主要介绍 TypeScript 的工程能力基础，包括类型指令、类型声明、命名空间这么几个部分。这些概念不仅可以帮助你了解到 TypeScript 工程能力的核心理念，也是接下来实战篇内容的前置基础。</p> <p>要开始学习工程能力，其实我们可以从一个很简单的场景开始。如果你已经有一定 TypeScript 的使用经验，那你很有可能遇到过这么一个场景：出现了莫名其妙的类型报错，但你又不知道从何入手解决，想让 TypeScript 直接忽略掉这一行出错的代码？此时，类型指令就是你最需要的工具。</p> <blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F17-declaration" target="_blank" rel="noopener noreferrer">Declaration<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="类型检查指令"><a href="#类型检查指令" class="header-anchor">#</a> 类型检查指令</h2> <p>在前端世界的许多工具中，其实都提供了 <strong>行内注释（Inline Comments）</strong> 的能力，用于支持在某一处特定代码<strong>使用特殊的配置来覆盖掉全局配置</strong>。最常见的即是 ESLint 与 Prettier 提供的禁用检查能力，如 <code>/* eslint-disable-next-lint */</code>、<code>&lt;!-- prettier-ignore --&gt;</code> 等。TypeScript 中同样提供了数个行内注释（这里我们称为类型指令），来进行单行代码或单文件级别的配置能力。这些指令均以 <code>// @ts-</code> 开头 ，我们依次来介绍。</p> <h3 id="ts-ignore-与-ts-expect-error"><a href="#ts-ignore-与-ts-expect-error" class="header-anchor">#</a> ts-ignore 与 ts-expect-error</h3> <p><code>ts-ignore</code> 应该是使用最为广泛的一个类型指令了，它的作用就是直接禁用掉对下一行代码的类型检查：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-ignore</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>基本上所有的类型报错都可以通过这个指令来解决，但由于它本质是上 ignore 而不是 disable，也就意味着如果下一行代码并没有问题，那使用 ignore 反而就是一个错误了。因此 TypeScript 随后又引入了一个更严格版本的 ignore，即 <code>ts-expect-error</code>，它只有在<strong>下一行代码真的存在错误时</strong>才能被使用，否则它会给出一个错误：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-expect-error</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>

<span class="token comment">// @ts-expect-error 错误使用此指令，报错</span>
<span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这里第二个 expect-error 指令会给出一个报错：<strong>无意义的 expect-error 指令</strong>。</p> <p>那这两个功能相同的指令应该如何取舍？我的建议是<strong>在所有地方都不要使用 ts-ignore</strong>，直接把这个指令打入冷宫封存起来。原因在上面我们也说了，对于这类 ignore 指令，本来就应当确保<strong>下一行真的存在错误时</strong>才去使用。</p> <p>这两个指令只能对单行代码生效，但如果我们有非常多的类型报错要处理（比如正在将一个 JavaScript 文件迁移到 TypeScript），难道要一个个为所有报错的地方都添加上禁用检查指令？当然不，正如 ESLint 中可以使用 <code>/* eslint-disable-next-line */</code> 禁用下一行代码检查，也可以使用 <code>/* eslint-disable */</code> 禁用整个文件检查一样， TypeScript 中也提供了对整个文件生效的类型指令：<code>ts-check</code> 与 <code>ts-nocheck</code>。</p> <h3 id="ts-check-与-ts-nocheck"><a href="#ts-check-与-ts-nocheck" class="header-anchor">#</a> ts-check 与 ts-nocheck</h3> <p>我们首先来看 ts-nocheck ，你可以把它理解为一个作用于整个文件的 ignore 指令，使用了 ts-nocheck 指令的 TS 文件将不再接受类型检查：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-nocheck 以下代码均不会抛出错误</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token string">'linbudu'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那么 <code>ts-check</code> 呢？这看起来是一个多余的指令，因为默认情况下 TS 文件不是就会被检查吗？实际上，这两个指令还可以用在 JS 文件中。要明白这一点，首先我们要知道，TypeScript 并不是只能检查 TS 文件，对于 JS 文件它也可以通过类型推导与 JSDoc 的方式进行不完全的类型检查。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// JavaScript 文件</span>
<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 JSDoc 标注变量类型</span>
<span class="token comment">/** @type {string} */</span>
<span class="token keyword">let</span> myName<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  prop <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上面的代码中，声明了初始值的 myAge 与 <code>Foo.prop</code> 都能被推导出其类型，而无初始值的 myName 也可以通过 JSDoc 标注的方式来显式地标注类型。</p> <p>但我们知道 JavaScript 是弱类型语言，表现之一即是变量可以<strong>被赋值为与初始值类型不一致的值</strong>，比如上面的例子进一步改写：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
myAge <span class="token operator">=</span> <span class="token string">&quot;90&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 与初始值类型不同</span>

<span class="token comment">/** @type {string} */</span>
<span class="token keyword">let</span> myName<span class="token punctuation">;</span>
myName <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span> <span class="token comment">// 与 JSDoc 标注类型不同</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们的赋值操作在类型层面显然是不成立的，但我们是在 JavaScript 文件中，因此这里并不会有类型报错。如果希望在 JS 文件中也能享受到类型检查，此时 <code>ts-check</code> 指令就可以登场了：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// @ts-check</span>
<span class="token comment">/** @type {string} */</span>
<span class="token keyword">const</span> myName <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span> <span class="token comment">// 报错！</span>

<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
myAge <span class="token operator">=</span> <span class="token string">'200'</span><span class="token punctuation">;</span> <span class="token comment">// 报错！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里我们的 <code>ts-check</code> 指令为 JavaScript 文件也带来了类型检查，而我们同时还可以使用 <code>ts-expect-error</code> 指令来忽略掉单行的代码检查：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// @ts-check</span>
<span class="token comment">/** @type {string} */</span>
<span class="token comment">// @ts-expect-error</span>
<span class="token keyword">const</span> myName <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>

<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
<span class="token comment">// @ts-expect-error</span>
myAge <span class="token operator">=</span> <span class="token string">'200'</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>而 <code>ts-nocheck</code> 在 JS 文件中的作用和 TS 文件其实也一致，即禁用掉对当前文件的检查。如果我们希望开启对所有 JavaScript 文件的检查，只是忽略掉其中少数呢？此时我们在 TSConfig 中启用 <code>checkJs</code> 配置，来开启<strong>对所有包含的 JS 文件的类型检查</strong>，然后使用 <code>ts-nocheck</code> 来忽略掉其中少数的 JS 文件。</p> <p>除了类型指令以外，在实际项目开发中还有一个你会经常打交道的概念：类型声明。</p> <h2 id="类型声明"><a href="#类型声明" class="header-anchor">#</a> 类型声明</h2> <p>在此前我们其实就已经接触到了类型声明，它实际上就是 <code>declare</code> 语法：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">var</span> <span class="token function-variable function">f1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token operator">:</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们可以直接访问这些声明：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">let</span> otherProp<span class="token operator">:</span> Foo<span class="token punctuation">[</span><span class="token string">'prop'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>但不能为这些声明变量赋值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// × 不允许在环境上下文中使用初始值</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// √ Foo</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> result<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这些类型声明就像我们在 TypeScript 中的类型标注一样，会存放着特定的类型信息，同时由于它们并不具有实际逻辑，我们可以很方便地使用类型声明来进行类型兼容性的比较、工具类型的声明与测试等等。</p> <p>除了手动书写这些声明文件，更常见的情况是你的 TypeScript 代码在编译后生成声明文件：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 源代码</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> input<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;林不渡&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">{</span>
  prop<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这段代码在编译后会生成一个 <code>.js</code> 文件和一个 <code>.d.ts</code> 文件，而后者即是类型声明文件：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 生成的类型定义</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这样一来，如果别的文件或是别的项目导入了这段代码，它们就能够从这些类型声明获得对应部分的类型，这也是类型声明的核心作用：<strong>将类型独立于 <code>.js</code> 文件进行存储</strong>。别人在使用你的代码时，就能够获得这些额外的类型信息。同时，如果你在使用别人没有携带类型声明的 <code>.js</code> 文件，也可以通过类型声明进行类型补全，我们在后面还会了解更多。</p> <p>接下来，我们要学习如何通过 TypeScript 类型声明的能力，让项目中的类型覆盖更加完整。</p> <h2 id="让类型定义全面覆盖你的项目"><a href="#让类型定义全面覆盖你的项目" class="header-anchor">#</a> 让类型定义全面覆盖你的项目</h2> <p>在开始学习下面的内容前，不妨先想想你是否遇到过这么几个场景？</p> <ul><li>想要使用一个 npm 包，但它发布的时间太早，根本没有携带类型定义，于是你的项目里就出现了这么一处没有被类型覆盖的地方。</li> <li>你想要在代码里导入一些非代码文件，反正 Webpack 会帮你处理，但是可恶的 TS 又报错了？</li> <li>这个项目在运行时动态注入了一些全局变量（如 <code>window.errorReporter</code>），你想要在代码里直接这样访问，却发现类型又报错了...</li></ul> <p>这些问题都可以通过类型声明来解决，这也是它的核心能力：<strong>通过额外的类型声明文件，在核心代码文件以外去提供对类型的进一步补全</strong>。类型声明文件，即 <code>.d.ts</code> 结尾的文件，它会自动地被 TS 加载到环境中，实现对应部分代码的类型补全。</p> <p>声明文件中并不包含实际的代码逻辑，它做的事只有一件：<strong>为 TypeScript 类型检查与推导提供额外的类型信息</strong>，而使用的语法仍然是 TypeScript 的 declare 关键字，只不过现在我们要进一步学习其它打开方式了。</p> <p>要详细学习声明文件与 declare 关键字，我们不妨先来看看如何解决上面的问题。首先是无类型定义的 npm 包，我们可以通过 declare module 的方式来提供其类型：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'pkg'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的 pkg 是一个没有类型定义的 npm 包（实际并不存在），我们来看如何为它添加类型提示。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'pkg'</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在我们的 res 就具有了 boolean 类型！<code>declare module 'pkg'</code> 会为默认导入 <code>foo</code> 添加一个具有 handler 的类型，虽然这里的 <code>pkg</code> 根本不存在。我们也可以在 <code>declare module</code> 中使用默认导出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'pkg2'</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">'pkg2'</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>在 <code>'pkg'</code> 的类型声明中，你也可以使用 <code>export const</code> ，效果是一致的，但由于对 <code>'pkg2'</code> 我们使用了默认导入，因此必须要有一个 <code>export default</code>。</p></blockquote> <p>除了为缺失类型的模块声明类型以外，使用类型声明我们还可以为非代码文件，如图片、CSS文件等声明类型。</p> <p>对于非代码文件，比如说 markdown 文件，假设我们希望导入一个 <code>.md</code> 文件，由于其本质和 npm 包一样是一条导入语句，因此我们可以类似地使用 declare module 语法：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// index.ts</span>
<span class="token keyword">import</span> raw <span class="token keyword">from</span> <span class="token string">'./note.md'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> content <span class="token operator">=</span> raw<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'NOTE'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">NOTE</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// declare.d.ts</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'*.md'</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> raw<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> raw<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>对于非代码文件的导入，更常见的其实是 <code>.css</code>、<code>.module.css</code>、<code>.png</code> 这一类，但基本语法都相似，我们在后面还会见到更多。</p> <p>总结一下，<code>declare module</code> 通常用于为没有提供类型定义的库进行类型的补全，以及为非代码文件提供基本类型定义。但在实际使用中，如果一个库没有内置类型定义，TypeScript 也会提示你，是否要安装 <code>@types/xxx</code> 这样的包。那这个包又是什么？</p> <h3 id="definitelytyped"><a href="#definitelytyped" class="header-anchor">#</a> DefinitelyTyped</h3> <p>简单来说，<code>@types/</code> 开头的这一类 npm 包均属于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，它是 TypeScript 维护的，专用于为社区存在的<strong>无类型定义的 JavaScript 库</strong>添加类型支持，常见的有 <code>@types/react</code> <code>@types/lodash</code> 等等。通过 DefinitelyTyped 来提供类型定义的包常见的有几种情况，如 Lodash 这样的库仍然有大量 JavaScript 项目使用，将类型定义内置在里面不一定是所有人都需要的，反而会影响包的体积。还有像 React 这种不是用纯 JavaScript / TypeScript 书写的库，需要自己来手写类型声明（React 是用 Flow 写的，这是一门同样为 JavaScript 添加类型的语言，或者说语法）。</p> <p>举例来说，只要你安装了 <code>@types/react</code>，TypeScript 会自动将其加载到环境中（实际上所有 <code>@types/</code> 下的包都会自动被加载），并作为 react 模块内部 API 的声明。但这些类型定义并不一定都是通过 <code>declare module</code>，我们下面介绍的命名空间 namespace 其实也可以实现一样的能力。</p> <p>先来看 <code>@types/node</code> 中与 <code>@types/react</code> 中分别是如何进行类型声明的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @types/node</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'fs'</span> <span class="token punctuation">{</span> 
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token comment">/** 省略 */</span><span class="token punctuation">)</span><span class="token operator">:</span> Buffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// @types/react</span>
<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>@types/node</code> 中仍然使用 <code>declare module</code> 的方式为 <code>fs</code> 这个内置模块声明了类型，而 <code>@types/react</code> 则使用的是我们没见过的 <code>declare namespace</code> 。别担心，我们会在后面详细介绍。</p> <p>回到上面的最后一个问题，如果第三方库并不是通过导出来使用，而是直接在全局注入了变量，如 CDN 引入与某些监控埋点 SDK 的引入，我们需要通过 <code>window.xxx</code> 的方式访问，而类型声明很显然并不存在。此时我们仍然可以通过类型声明，但不再是通过 <code>declare module</code> 了。</p> <h3 id="扩展已有的类型定义"><a href="#扩展已有的类型定义" class="header-anchor">#</a> 扩展已有的类型定义</h3> <p>对全局变量的声明，还是以 window 为例，实际上我们如果 Ctrl + 点击代码中的 window，会发现它已经有类型声明了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">var</span> window<span class="token operator">:</span> Window <span class="token operator">&amp;</span> <span class="token keyword">typeof</span> globalThis<span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这行代码来自于 <code>lib.dom.d.ts</code> 文件，它定义了对浏览器文档对象模型的类型声明，这就是 TypeScript 提供的内置类型，也是“出厂自带”的类型检查能力的依据。类似的，还有内置的 <code>lib.es2021.d.ts</code> 这种文件定义了对 ECMAScript 每个版本的类型声明新增或改动等等。</p> <p>我们要做的，实际上就是在内置类型声明的基础之上，再新增一部分属性。而别忘了，在 JavaScript 中当你访问全局变量时，是可以直接忽略 <code>window</code> 的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>反过来，在类型声明中，如果我们直接声明一个变量，那就相当于将它声明在了全局空间中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 类型声明</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">errorReporter</span><span class="token operator">:</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token comment">// 实际使用</span>
<span class="token function">errorReporter</span><span class="token punctuation">(</span><span class="token string">&quot;err!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>而如果我们就是想将它显式的添加到已有的 <code>Window</code> 接口中呢？在接口一节中我们其实已经了解到，如果你有多个同名接口，那么<strong>这些接口实际上是会被合并的</strong>，这一特性在类型声明中也是如此。因此，我们再声明一个 Window 接口即可：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">userTracker</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

window<span class="token punctuation">.</span><span class="token function">userTracker</span><span class="token punctuation">(</span><span class="token string">&quot;click!&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>类似的，我们也可以扩展来自 <code>@types/</code> 包的类型定义：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">'fs'</span> <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> bump <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>总结一下这两个部分，TypeScript 通过 DefinitelyTyped ，也就是 <code>@types/</code> 系列的 npm 包来为无类型定义的 JavaScript npm 包提供类型支持，这些类型定义 的 npm 包内部其实就是数个 <code>.d.ts</code> 这样的声明文件。</p> <p>而这些声明文件主要通过 declare / namespace 的语法进行类型的描述，我们可以通过项目内额外的声明文件，来实现为非代码文件的导入，或者是全局变量添加上类型声明。而对于多个类型声明文件，如果我们想复用某一个已定义的类型呢？此时三斜线指令就该登场了。</p> <h2 id="三斜线指令"><a href="#三斜线指令" class="header-anchor">#</a> 三斜线指令</h2> <p>三斜线指令就像是声明文件中的导入语句一样，它的作用就是<strong>声明当前的文件依赖的其他类型声明</strong>。而这里的“其他类型声明”包括了 TS 内置类型声明（<code>lib.d.ts</code>）、三方库的类型声明以及你自己提供的类型声明文件等。</p> <p>三斜线指令本质上就是一个自闭合的 XML 标签，其语法大致如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference path=&quot;./other.d.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>
<span class="token comment">/// &lt;reference lib=&quot;dom&quot; /&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>需要注意的是，三斜线指令必须被放置在文件的顶部才能生效</strong>。</p> <p>这里的三条指令作用其实都是声明当前文件依赖的外部类型声明，只不过使用的方式不同：分别使用了 path、types、lib 这三个不同属性，我们来依次解析。</p> <p>使用 path 的 reference 指令，其 path 属性的值为一个相对路径，指向你项目内的其他声明文件。而在编译时，TS 会沿着 path 指定的路径不断深入寻找，最深的那个没有其他依赖的声明文件会被最先加载。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @types/node 中的示例</span>
<span class="token comment">/// &lt;reference path=&quot;fs.d.ts&quot; /&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用 types 的 reference 指令，其 types 的值是一个包名，也就是你想引入的 <code>@types/</code> 声明，如上面的例子中我们实际上是在声明当前文件对 <code>@types/node</code> 的依赖。而如果你的代码文件（<code>.ts</code>）中声明了对某一个包的类型导入，那么在编译产生的声明文件（<code>.d.ts</code>）中会自动包含引用它的指令。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>使用 lib 的 reference 指令类似于 types，只不过这里 lib 导入的是 TypeScript 内置的类型声明，如下面的例子我们声明了对 <code>lib.dom.d.ts</code> 的依赖：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// vite/client.d.ts</span>
<span class="token comment">/// &lt;reference lib=&quot;dom&quot; /&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而如果我们使用 <code>/// &lt;reference lib=&quot;esnext.promise&quot; /&gt;</code>，那么将依赖的就是 <code>lib.esnext.promise.d.ts</code> 文件。</p> <p>这三种指令的目的都是引入当前文件所依赖的其他类型声明，只不过适用场景不同而已。</p> <p>如果说三斜线指令的作用就像导入语句一样，那么命名空间（namespace）就像一个模块文件一样，将一组强相关的逻辑收拢到一个命名空间内部。</p> <h2 id="命名空间"><a href="#命名空间" class="header-anchor">#</a> 命名空间</h2> <p>假设一个场景，我们的项目里需要接入多个平台的支付 SDK，最开始只有微信支付和支付宝：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>然后又多了美团支付、虚拟货币支付（比如 Q 币）、信用卡支付等等：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>随着业务的不断发展，项目中可能需要引入越来越多的支付 SDK，甚至还有比特币和以太坊，此时将这些所有的支付都放在一个文件内未免过于杂乱了。这些支付方式其实大致可以分成两种：现实货币与虚拟货币。此时我们就可以使用命名空间来区分这两类 SDK：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">namespace</span> RealCurrency <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">namespace</span> VirtualCurrency <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><p>注意，这里的代码是在 <code>.ts</code> 文件中的，此时它是具有实际逻辑意义的，也不能和类型混作一谈。</p></blockquote> <p>而命名空间的使用类似于枚举：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> weChatPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealCurrency</span><span class="token punctuation">.</span><span class="token function">WeChatPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>唯一需要注意的是，命名空间内部实际上就像是一个独立的代码文件，因此其中的变量需要导出以后，才能通过 <code>RealCurrency.WeChatPaySDK</code> 这样的形式访问。</p> <p>如果你开始学习前端的时间较早，一定会觉得命名空间的编译产物很眼熟——它就像是上古时期里使用的伪模块化方案：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">var</span> RealCurrency<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">RealCurrency</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    RealCurrency<span class="token punctuation">.</span>WeChatPaySDK <span class="token operator">=</span> WeChatPaySDK<span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">ALiPaySDK</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    RealCurrency<span class="token punctuation">.</span>ALiPaySDK <span class="token operator">=</span> ALiPaySDK<span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    RealCurrency<span class="token punctuation">.</span>MeiTuanPaySDK <span class="token operator">=</span> MeiTuanPaySDK<span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    RealCurrency<span class="token punctuation">.</span>CreditCardPaySDK <span class="token operator">=</span> CreditCardPaySDK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>RealCurrency <span class="token operator">||</span> <span class="token punctuation">(</span>RealCurrency <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>实际上，命名空间的作用也正是实现简单的模块化功能，在 TypeScript 中引入它时（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-1-5.html%23namespace-keyword" target="_blank" rel="noopener noreferrer">1.5 版本<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），前端的模块化方案还处于混沌时期。</p> <p>命名空间的内部还可以再嵌套命名空间，比如在虚拟货币中再新增区块链货币一类，此时嵌套的命名空间也需要被导出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">namespace</span> VirtualCurrency <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">namespace</span> BlockChainCurrency <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> ethPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualCurrency</span><span class="token punctuation">.</span>BlockChainCurrency<span class="token punctuation">.</span><span class="token function">ETHPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>类似于类型声明中的同名接口合并，命名空间也可以进行合并，但需要通过三斜线指令来声明导入。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// animal.ts</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> ProtectedAnimals <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// dog.ts</span>
<span class="token comment">/// &lt;reference path=&quot;animal.ts&quot; /&gt;</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// corgi.ts</span>
<span class="token comment">/// &lt;reference path=&quot;dog.ts&quot; /&gt;</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">namespace</span> Corgi <span class="token punctuation">{</span>
      <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>实际使用时需要导入全部的依赖文件：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference path=&quot;animal.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference path=&quot;dog.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference path=&quot;corgi.ts&quot; /&gt;</span>

Animal<span class="token punctuation">.</span>Dog<span class="token punctuation">.</span>Corgi<span class="token punctuation">.</span><span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>除了在 <code>.ts</code> 文件中使用以外，命名空间也可以在声明文件中使用，即 <code>declare namespace</code>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">let</span> dog<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Dog<span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> cat<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Cat<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>但如果你在 <code>@types/</code> 系列的包下，想要通过 namespace 进行模块的声明，还需要注意将其导出，然后才会加载到对应的模块下。以 <code>@types/react</code> 为例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token operator">=</span> React<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">as</span> <span class="token keyword">namespace</span> React<span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">{</span>
  <span class="token comment">// 省略了不必要的类型标注</span>
  <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>首先我们声明了一个命名空间 React，然后使用 <code>export = React</code> 将它导出了，这样我们就能够在从 react 中导入方法时，获得命名空间内部的类型声明，如 useState。</p> <p>从这一个角度来看，<code>declare namespace</code> 其实就类似于普通的 <code>declare</code> 语法，只是内部的类型我们不再需要使用 <code>declare</code> 关键字（比如我们直接在 namespace 内部 <code>function useState(): []</code> 即可）。</p> <p>而还有一行 <code>export as namespace React</code> ，它的作用是在启用了 <code>--allowUmdGlobalAccess</code> 配置的情况下，允许将这个模块作为全局变量使用（也就是不导入直接使用），这一特性同样也适用于通过 CDN 资源导入模块时的变量类型声明。</p> <p>除了这两处 namespace 使用，React 中还利用 namespace 合并的特性，在全局的命名空间中注入了一些类型：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> global <span class="token punctuation">{</span>
  <span class="token keyword">namespace</span> <span class="token constant">JSX</span> <span class="token punctuation">{</span>
    <span class="token keyword">interface</span> <span class="token class-name">Element</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这也是为什么我们可以在全局使用 <code>JSX.Element</code> 作为类型标注。</p> <p>除了类型声明中的导入——三斜线指令，以及类型声明中的模块——命名空间以外，TypeScript 还允许你将这些类型去导入到代码文件中。</p> <h2 id="仅类型导入"><a href="#仅类型导入" class="header-anchor">#</a> 仅类型导入</h2> <p>在 TypeScript 中，当我们导入一个类型时其实并不需要额外的操作，和导入一个实际值是完全一样的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// foo.ts</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">FooType</span> <span class="token operator">=</span> <span class="token builtin">any</span><span class="token punctuation">;</span>

<span class="token comment">// index.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Foo<span class="token punctuation">,</span> FooType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./foo&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>虽然类型导入和值导入存在于同一条导入语句中，在编译后的 JS 代码里还是只会有值导入存在，同时在编译的过程中，值与类型所在的内存空间也是分开的。</p> <p>在这里我们只能通过名称来区分值和类型，但为每一个类型都加一个 Type 后缀也太奇怪了。实际上，我们可以更好地区分值导入和类型导入，只需要通过 <code>import type</code> 语法即可：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> FooType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./foo&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样会造成导入语句数量激增，如果你想同时保持较少的导入语句数量又想区分值和类型导入，也可以使用同一导入语句内的方式（需要 4.6 版本以后才支持）：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Foo<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token class-name">FooType</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./foo&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这实际上是我个人编码习惯的一部分，即<strong>对导入语句块的规范整理</strong>。在大型项目中一个文件顶部有几十条导入语句是非常常见的，它们可能来自第三方库、UI库、项目内工具方法、样式文件、类型，项目内工具方法可能又分成 constants、hooks、utils、config 等等。如果将这些所有类型的导入都混乱地堆放在一起，对于后续的维护无疑是灾难。因此，我通常会将这些导入按照实际意义进行组织，顺序大致是这样：</p> <ul><li>一般最上面会是 React；</li> <li>第三方 UI 组件，然后是项目内封装的其他组件；</li> <li>第三方工具库，然后是项目内封装的工具方法，具体 hooks 和 utils 等分类的顺序可以按照自己偏好来；</li> <li>类型导入，包括第三方库的类型导入、项目内的类型导入等；</li> <li>样式文件，<code>CSS-IN-JS</code> 方案的组件应该被放在第二条中其他组件部分。</li></ul> <p>示例如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Button<span class="token punctuation">,</span> Dialog <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'ui'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ChildComp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./child'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/store'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useCookie <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/hooks/useCookie'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">SOME_CONSTANTS</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/utils/constants'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token constant">FC</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> Foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/typings/foo'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> Shared <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@/typings/shared'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'./index.module.scss'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="总结与预告"><a href="#总结与预告" class="header-anchor">#</a> 总结与预告</h2> <p>在这一节，我们主要了解了 TypeScript 在工程层面的基础能力，包括<strong>类型指令</strong>、<strong>类型声明</strong>、<strong>命名空间</strong>三个部分。</p> <p>类型声明相关的能力几乎是所有规模的工程都会使用到的（你总会遇到没有提供类型定义的库吧），通过大量的额外类型声明我们可以实现更复杂、更准确的类型保护，以及为上古时期的 JavaScript npm 包提供类型定义，即 DefinitelyTyped。但类型指令却相反，它绝对不应该被滥用，无论是相当于后门的 <code>ts-ignore</code> 还是稍显安全的 <code>ts-expect-error</code> 。我们会在后面介绍如何通过 ESLint 规则来进行对应地约束。</p> <p>而三斜线指令与命名空间这两个概念，虽然已经不再被大量使用，但了解它们诞生与存在的意义同样对理解整个 TypeScript 工程能力很有帮助。在下一节，我们还会与三斜线指令再次碰面。</p> <p>无论你是在将 TypeScript 集成到什么框架或者工具里，其实你在做的只是一件事，那就是<strong>类型，类型，类型！</strong>。包括我们在下一节所要学习的 React 与 TypeScript 结合实战，其实本质上也是在学习如何让你的 React 组件也拥有可靠的类型支持。</p> <h2 id="扩展阅读"><a href="#扩展阅读" class="header-anchor">#</a> 扩展阅读</h2> <h3 id="通过-jsdoc-在-js-文件中获得类型提示"><a href="#通过-jsdoc-在-js-文件中获得类型提示" class="header-anchor">#</a> 通过 JSDoc 在 JS 文件中获得类型提示</h3> <p>在上面我们提到了可以在 JS 文件中通过 JSDoc 来标注变量类型，而既然有了类型标注，那么自然也能享受到像 TS 文件中一样的类型提示了。但这里我们需要使用更强大一些的 JSDoc 能力：在 <code>@type {}</code> 中使用导入语句！</p> <p>以拥有海量配置项的 Webpack 为例：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">/** @type {import(&quot;webpack&quot;).Configuration} */</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>此时你会发现已经拥有了如臂使指的类型提示：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3074e724e8ef48f9ba02fae7e2c70b71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p> <p>类似的，也可以直接进行导出：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token comment">/** @type { import('webpack').Configuration } */</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当然，Webpack 本身也支持通过 ts 文件进行配置，在使用 TS 进行配置时，一种方式是简单地使用它提供的类型作为一个对象的标注。而目前更常见的一种方式其实是框架内部提供 <code>defineConfig</code> 这样的方法，让你能直接获得类型提示，如 Vite 中的做法：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vite'</span>
<span class="token keyword">import</span> react <span class="token keyword">from</span> <span class="token string">'@vitejs/plugin-react'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">10/9/2023, 5:43:25 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blogs/docs/TypeScript全面进阶指南/19.类型编程新范式：模板字符串工具类型进阶.html" class="prev">
          19.类型编程新范式：模板字符串工具类型进阶
        </a></span> <span class="next"><a href="/blogs/docs/TypeScript全面进阶指南/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html">
          21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-b57cc07c data-v-7dd95ae2></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><canvas id="vuepress-canvas-cursor"></canvas><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div><div></div><!----><div class="RibbonAnimation"></div></div></div>
    <script src="/blogs/assets/js/app.500cfb4c.js" defer></script><script src="/blogs/assets/js/3.ab704d4e.js" defer></script><script src="/blogs/assets/js/1.120dd0c6.js" defer></script><script src="/blogs/assets/js/127.7f484897.js" defer></script><script src="/blogs/assets/js/15.a0d3f198.js" defer></script>
  </body>
</html>
