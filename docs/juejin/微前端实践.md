---
title: 微前端实践
date: 2023-02-16
tags:
 - 技巧
categories: 
 - 其他
---

## 


## 快速上手

这里以 vue2.x + qiankun  为例

我们先用 vue-cli快速创建一个项目，作为主应用，这里把他取名为 main-app

```sh
vue create main-app
```
为跟实际项目更接近，我们暂时手动选择了安装这些
![](./img/main-app.png)

项目创建完后，我们把 main-app 复制一份作为子应用，改名为 sub-app

好的，基本的准备工作已经完成，我们开始基于刚刚创建的两个项目改造成微前端应用

在 main-app 中，安装 qiankun：

```sh
yarn add qiankun # 或者 npm i qiankun -S
```

目录 src 下新建 ```src/qiankun/index.js```

注册微应用并启动，代码如下：

```js
import { registerMicroApps, start } from "qiankun";
import store from "@/store";


registerMicroApps([
  {
    name: "sub-vue",
    entry: "http://localhost:7663", // 微应用入口
    container: "#subapp-viewport", // 微应用挂载的div
    activeRule: "/sub-app/"
  }
]);

export default start;
```

这里我们把微应用的路由前缀定义为 ```sub-app```

views 目录下新建一个组件 ```src/views/qiankun/index.vue```,我们提供一个 id 为 subapp-viewport 的容器 DOM 供子应用挂载

```vue
<template>
  <div id="subapp-viewport"></div>
</template>

<script>
import start from "@/qiankun/index";
export default {
  mounted() {
    // 启动微前端
    if (!window.qiankunStarted) {
      window.qiankunStarted = true;
      start();
    }
    console.log("qiankunStarted", window.qiankunStarted);
  }
};
</script>
```

找到路由文件夹，```router/index.js```下加入如下路由，用以匹配微应用 
```js
{
  path: "/sub-app/*",
  meta: { title: "子应用" },
  component: () => import("@/views/qiankun/index")
}
```

### 微应用

上面我们对主应用的改造基本完成，接下来我们对之前复制出来的 sub-app 稍加改造，使其成为微应用


先找到 ```/src/router/index.js``` ,对路由文件稍加改造

删除 
```js
const router = new VueRouter({
  mode: "history",
  base: process.env.BASE_URL,
  routes
});

export default router;
```

于文件最后添加 
```js
export default routes;
```
找到```main.js```

将 ```import router from './router'``` 修改为 ```import routes from './routes'``` ,并增加 ```import VueRouter from "vue-router";```

删除：
```js
new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app");
```
增加 

```js
let router = null;
let instance = null;

if (window.__POWERED_BY_QIANKUN__) {
  // eslint-disable-next-line
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}

function render(props = {}) {
  const { container } = props;
  router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? "/sub-vue/" : "/", // 抛出路由加前缀
    mode: "history",
    routes
  });

  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app");
}

if (!window.__POWERED_BY_QIANKUN__) {
  render();
}
export default instance;

export async function bootstrap() {
  console.log("[vue] vue app bootstraped");
}

export async function mount(props) {
  // props 包含主应用传递的参数  也包括为子应用 创建的节点信息
  if (props.systemCode) {
    store.state.systemCode = props.systemCode;
  }
  render(props);
}

export async function unmount() {
  instance.$destroy();
  instance = null;
  router = null;
}
```

最终文件修改如下

```js
// main.js
import Vue from "vue";
import App from "./App.vue";
import routes from "./router";
import store from "./store";
import VueRouter from "vue-router";

Vue.config.productionTip = false;
// new Vue({
//   router,
//   store,
//   render: h => h(App)
// }).$mount('#app')

// 微前端 - 子应用配置
let router = null;
let instance = null;

if (window.__POWERED_BY_QIANKUN__) {
  // eslint-disable-next-line
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__
}

function render(props = {}) {
  const { container } = props;
  router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? "/" : "/", // 抛出路由加前缀
    mode: "history",
    routes
  });

  instance = new Vue({
    router,
    store,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app");
}

if (!window.__POWERED_BY_QIANKUN__) {
  render();
}
export default instance;

export async function bootstrap() {
  console.log("[vue] vue app bootstraped");
}

export async function mount(props) {
  // props 包含主应用传递的参数  也包括为子应用 创建的节点信息
  if (props.systemCode) {
    store.state.systemCode = props.systemCode;
  }
  render(props);
}

export async function unmount() {
  instance.$destroy();
  instance = null;
  router = null;
}
```

在 sub-app 下新建 ```vue.config.js``` ,增加配置如下

```js
const { name } = require('./package.json')

module.exports = {
  publicPath: '/', // 打包相对路径
  devServer: {
    port: 7663, // 运行端口号
    headers: {
      'Access-Control-Allow-Origin': '*'
    }
  },
  chainWebpack: config => config.resolve.symlinks(false),
  configureWebpack: {
    output: {
      // 把子应用打包成 umd 库格式
      library: `${name}-[name]`,
      libraryTarget: 'umd',
      jsonpFunction: `webpackJsonp_${name}`
    }
  }
}
```
最后我们在微应用新建一个测试页面以供嵌入主应用，路由暂且取名 ```/test```

```vue
// views/sub-app/index.vue
<template>
  <div class="sub-app">
    我是子应用
  </div>
</template>

<style lang="scss" scoped>
.sub-app {
  cursor: pointer;
  background-color: aqua;
}
</style>
```

至此，我们对主应用和微应用的改造基本完成，接下来我们测试一下，我们在主应用的 ```app.vue```添加一个按钮，使其点击的时候添加事件 ```this.$router.push('/sub-vue/test')``` 跳转至子应用

![](./img/qiankun-main.png)

当我们点击按钮后,可以看到，微应用嵌入成功

![](./img/qiankun-sub.png)


## 微前端常见问题

### 微前端子应用路由跳转

```js
/**
 * 微前端子应用路由跳转
 * @param {String} url 路由
 * @param {Object} mainRouter 主应用路由实例（例如this.$store.state.router）
 * @param {*} params 状态对象：传给目标路由的信息,可为空
 */

const qiankunJump = (url, mainRouter, params) => {
  if (mainRouter) {
    // 使用主应用路由实例跳转
    mainRouter.push({ path: url, query: params })
    return
  }
  // 未传递主应用路由实例，传统方式跳转
  let searchParams = '?'
  let targetUrl = url
  if (typeOf(params) === 'object' && Object.keys(params).length) {
    Object.keys(params).forEach(item => {
      searchParams += `${item}=${params[item]}&`
    })
    targetUrl = targetUrl + searchParams.slice(0, searchParams.length - 1)
  }
  window.history.pushState(null, '', targetUrl)
}
```

### qiankun+vue 适配vue-pdf踩坑

找到vue-pdf的依赖包下的vuePdfNoSss.vue

```vue
//找到vue-pdf的依赖包下的vuePdfNoSss.vue
<style src="./annotationLayer.css"></style>
<script>
	import componentFactory from './componentFactory.js'
	if ( process.env.VUE_ENV !== 'server' ) {
		var pdfjsWrapper = require('./pdfjsWrapper.js').default;
		var PDFJS = require('pdfjs-dist/es5/build/pdf.js');
		if ( typeof window !== 'undefined' && 'Worker' in window && navigator.appVersion.indexOf('MSIE 10') === -1 ) {
      // 注释原本的引入方法
			// var PdfjsWorker = require('worker-loader!pdfjs-dist/es5/build/pdf.worker.js');
			  var PdfjsWorker=require('pdfjs-dist/es5/build/pdf.worker.js');
			PDFJS.GlobalWorkerOptions.workerPort = new PdfjsWorker();
		}
		var component = componentFactory(pdfjsWrapper(PDFJS));
	} else {
		var component = componentFactory({});
	}
	export default component;
</script>
```

修改项目的配置文件vue.config.js

```js
chainWebpack: (config) => {
  config.module
    .rule('worker')
    .test(/\.worker\.js$/)
    .use('worker-loader').loader('worker-loader')
    .options({
      inline: true,
      fallback: false
    }).end();
}
```

### 主项目和子项目部署到一起，子项目部署到二级目录(不占用这么多端口)

[主项目和子项目部署到一起，子项目部署到二级目录](https://github.com/umijs/qiankun/issues/400#issuecomment-676947927)

### qiankun在子应用中引入百度地图时报错解决

修改主应用 start 方法

```js
// 启动微前端
if (!window.qiankunStarted) {
  window.qiankunStarted = true
  start({
    singular: false,
    excludeAssetFilter: (assetUrl) => {
      // 过滤baidu
      const wihiteWords = ['baidu']
      if (wihiteWords.includes(assetUrl)) {
        return true
      }
      return wihiteWords.some(w => {
        return assetUrl.includes(w)
      })
    }
  })
}
```