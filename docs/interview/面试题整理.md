---
title: 面试题整理
date: 2023-03-04 20:00:38
tags:
  - 其他
  - 面试
categories:
  - 面试
---

## 如何判断一个元素是否在可视区域中

1. offsetTop、scrollTop
2. getBoundingClientRect
3. IntersectionObserver

- getBoundingClientRect

![](./img/getBoundingClientRect.png)

- IntersectionObserver

![](./img/intersectionObserver.png)

[参考](http://fanyouf.gitee.io/interview/nb/03.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)

## 实现一个函数，入参是一个 fn，延迟 5s 执行，并且拿到返回值

```js
function sleep(fn) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(fn())
    }, 5000)
  })
}

function f() {
  return '彼时彼刻，恰如此时此刻'
}

console.log(Date.now())
const old = Date.now()
sleep(f).then((res) => {
  console.log(res, Date.now() - old)
})
```

## 通用的错误处理实现

1. 代码中加入 try catch，并在 catch 语句中处理异常
2. 使用全局的 error 事件来监听未捕获的异常
3. vue 项目中，可以用 Vue.config.errorHandler 配置全局错误处理函数

## vue

- [Vue2 和 Vue3 的响应式原理比对](https://juejin.cn/post/7124351370521477128)

## 前端模块化

[当你被问到前端模块化](https://juejin.cn/post/7193887403570888765)

## 大文件断点续传

通过 file.slice 方法对大文件进行切割，利用 spark-md5.js 计算文件唯一的 hash 值，点击开始上传，发送文件的 hash 值给服务端，服务端返回是否需要上传以及已经上传过的区块号码（hash+分割时的下标），根据服务端返回，若需要上传则过滤掉已经上传的区块继续上传余下的区块，若不需要上传则表示已经上传过，实现秒传的效果。

## ['1','2','3'].map(parseInt)

实际相当于：

```js
;['1', '2', '3'].map((item, index) => parseInt(item, index))
// parseInt('1',0) // 1
// parseInt('2',1) // NaN
// parseInt('3',2) // NaN
```

## SaaS 销售

SaaS 销售是指企业使用软件即服务（Software-as-a-Service）模式进行产品的销售，在这个过程当中，能够达到客户和供应商的双赢局面。

TOB 和 TOC：

1、面向对象不同：TOB 企业主要面向的是企业即客户，而不是个人用户；TOC 面向的是个人即用户。
2、关注点不同：TOB 是服务思维，关注的核心是效率提升；TOC 是流量思维，关注的核心是用户体验。

## 项目中遇到的重难点

当被提问到一个很大的问题时，进行问题的拆解，

1. 解释是什么问题
2. 解释这个技术点的应用点，应用场景
3. 整理这个问题的优缺点

qiankun vue-pdf

npm i patch-package

patch-package 修改 node_modules 下的依赖包源码，

## 技术选型的依据

- 相关社区是否成熟
- 公司是否有已有经验积累
- 团队成员的学习成本

## apply、call 传入基础数据类型如 number，string 会返回什么

## 设计一个图片懒加载 SDK

```js
const throttle = (fn, delay) => {
  let timer = null
  return function (...args) {
    if (!timer) {
      setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}

const lazyLoadImages = () => {
  const images = document.querySelectorAll('img[data-src]')
  images.forEach((img) => {
    const rect = img.getBoundingClientRect()
    if (rect.top < window.innerHeight) {
      img.src = img.dataSet.src
      img.removeAttribute('data-src')
    }
  })
}

const throttledLazyLoad = throttle(lazyLoadImages, 100)

window.addEventListener('scroll', throttledLazyLoad)
```

- getBoundingClientRect()
  用于获取元素大小及其相对于视口的位置的方法

- x：元素左上角相对于视口的横坐标
- y：元素左上角相对于视口的纵坐标
- width：元素的宽度
- height：元素的高度
- top：元素顶部相对于视口顶部的距离
- right：元素右侧相对于视口左侧的距离
- bottom：元素底部相对于视口顶部的距离
- left：元素左侧相对于视口左侧的距离

判断元素是否在视口中，从而实现图片的懒加载等功能

## 实现大文件并行下载

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://www.unpkg.com/axios@1.3.5/dist/axios.min.js"></script>
  </head>
  <body>
    <img id="img" />
    <script>
      async function concurrencyDownload(path, size, chunkSize) {
        let chunkNum = Math.ceil(size / chunkSize)

        const downloadTask = []
        for (let i = 1; i <= chunkNum; i++) {
          const rangeStart = chunkSize * (i - 1)
          const rangeEnd = chunkSize * i - 1

          downloadTask.push(
            axios.get(path, {
              headers: {
                Range: `bytes=${rangeStart}-${rangeEnd}`,
              },
              responseType: 'arraybuffer',
            })
          )
        }
        const arrayBuffers = await Promise.all(
          downloadTask.map((task) => {
            return task.then((res) => res.data)
          })
        )
        return mergeArrayBuffer(arrayBuffers)
      }

      function mergeArrayBuffer(arrays) {
        let totalLen = 0
        for (let arr of arrays) {
          totalLen += arr.byteLength
        }
        let res = new Uint8Array(totalLen)
        let offset = 0
        for (let arr of arrays) {
          let uint8Arr = new Uint8Array(arr)
          res.set(uint8Arr, offset)
          offset += arr.byteLength
        }
        return res.buffer
      }

      ;(async function () {
        const { data: len } = await axios.get('http://localhost:3000/length')
        const res = await concurrencyDownload(
          'http://localhost:3000',
          len,
          300000
        )
        console.log(res)

        const blob = new Blob([res])
        const url = URL.createObjectURL(blob)
        img.src = url
      })()
    </script>
  </body>
</html>
```

[JavaScript 中如何实现大文件并行下载？](https://juejin.cn/post/6954868879034155022)、[基于 HTTP Range 实现文件分片并发下载！](https://juejin.cn/post/7219140831365857317)、[手摸手，带你完成大文件分片下载](https://juejin.cn/post/7025885508748181512)


## code review 做的一些事情

- 代码规范：开启eslint，变量命名，文件命名，代码语义这些
- 一些重复代码的抽离复用
- 代码或者某些函数方法是否可以优化拆分
- 是否便于后续的扩展

## 学习一门新语言或新技术，需要考虑哪些方面

- 他的优势及应用场景
- 语法（变量，常量，数据类型，函数）
- 内置的模块及一些常用api
- 常用的第三方库和库
- 怎么调试及发布