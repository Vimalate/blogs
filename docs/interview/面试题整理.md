---
title: 面试题整理
date: 2023-03-04 20:00:38
tags:
  - 其他
  - 面试
categories:
  - 面试
---

## 如何判断一个元素是否在可视区域中

1. offsetTop、scrollTop
2. getBoundingClientRect
3. IntersectionObserver

- getBoundingClientRect

![](./img/getBoundingClientRect.png)

- IntersectionObserver

![](./img/intersectionObserver.png)

[参考](http://fanyouf.gitee.io/interview/nb/03.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)

## 实现一个函数，入参是一个 fn，延迟 5s 执行，并且拿到返回值

```js
function sleep(fn) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(fn())
    }, 5000)
  })
}

function f() {
  return '彼时彼刻，恰如此时此刻'
}

console.log(Date.now())
const old = Date.now()
sleep(f).then((res) => {
  console.log(res, Date.now() - old)
})
```

## 通用的错误处理实现

1. 代码中加入 try catch，并在 catch 语句中处理异常
2. 使用全局的 error 事件来监听未捕获的异常
3. vue 项目中，可以用 Vue.config.errorHandler 配置全局错误处理函数

## vue

- [Vue2 和 Vue3 的响应式原理比对](https://juejin.cn/post/7124351370521477128)

## 前端模块化

[当你被问到前端模块化](https://juejin.cn/post/7193887403570888765)

## 大文件断点续传

通过 file.slice 方法对大文件进行切割，利用 spark-md5.js 计算文件唯一的 hash 值，点击开始上传，发送文件的 hash 值给服务端，服务端返回是否需要上传以及已经上传过的区块号码（hash+分割时的下标），根据服务端返回，若需要上传则过滤掉已经上传的区块继续上传余下的区块，若不需要上传则表示已经上传过，实现秒传的效果。

## ['1','2','3'].map(parseInt)

实际相当于：

```js
;['1', '2', '3'].map((item, index) => parseInt(item, index))
// parseInt('1',0) // 1
// parseInt('2',1) // NaN
// parseInt('3',2) // NaN
```

## SaaS 销售

SaaS 销售是指企业使用软件即服务（Software-as-a-Service）模式进行产品的销售，在这个过程当中，能够达到客户和供应商的双赢局面。

TOB 和 TOC：

1、面向对象不同：TOB 企业主要面向的是企业即客户，而不是个人用户；TOC 面向的是个人即用户。
2、关注点不同：TOB 是服务思维，关注的核心是效率提升；TOC 是流量思维，关注的核心是用户体验。

## 项目中遇到的重难点

当被提问到一个很大的问题时，进行问题的拆解，

1. 解释是什么问题
2. 解释这个技术点的应用点，应用场景
3. 整理这个问题的优缺点

qiankun vue-pdf

npm i patch-package

patch-package 修改 node_modules 下的依赖包源码，

## 技术选型的依据

- 相关社区是否成熟
- 公司是否有已有经验积累
- 团队成员的学习成本

## apply、call 传入基础数据类型如 number，string 会返回什么

## 设计一个图片懒加载 SDK

```js
const throttle = (fn, delay) => {
  let timer = null
  return function (...args) {
    if (!timer) {
      setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}

const lazyLoadImages = () => {
  const images = document.querySelectorAll('img[data-src]')
  images.forEach((img) => {
    const rect = img.getBoundingClientRect()
    if (rect.top < window.innerHeight) {
      img.src = img.dataSet.src
      img.removeAttribute('data-src')
    }
  })
}

const throttledLazyLoad = throttle(lazyLoadImages, 100)

window.addEventListener('scroll', throttledLazyLoad)
```

- getBoundingClientRect()
  用于获取元素大小及其相对于视口的位置的方法

- x：元素左上角相对于视口的横坐标
- y：元素左上角相对于视口的纵坐标
- width：元素的宽度
- height：元素的高度
- top：元素顶部相对于视口顶部的距离
- right：元素右侧相对于视口左侧的距离
- bottom：元素底部相对于视口顶部的距离
- left：元素左侧相对于视口左侧的距离

断元素是否在视口中，从而实现图片的懒加载等功能

## 实现大文件并行下载

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://www.unpkg.com/axios@1.3.5/dist/axios.min.js"></script>
  </head>
  <body>
    <img id="img" />
    <script>
      const p1 = new Promise((resolve, reject) => {
        axios
          .get('http://localhost:3000', {
            headers: {
              Range: 'bytes=0-300000',
            },
            responseType: 'arraybuffer',
          })
          .then((res) => {
            resolve(res.data)
          })
          .catch((err) => {
            reject(err)
          })
      })

      const p2 = new Promise((resolve, reject) => {
        axios
          .get('http://localhost:3000', {
            headers: {
              Range: 'bytes=300001-',
            },
            responseType: 'arraybuffer',
          })
          .then((res) => {
            resolve(res.data)
          })
          .catch((err) => {
            reject(err)
          })
      })

      Promise.all([p1, p2]).then((res) => {
        const [buffer1, buffer2] = res

        const arr = new Uint8Array(buffer1.byteLength + buffer2.byteLength)

        const arr1 = new Uint8Array(buffer1)
        arr.set(arr1, 0)

        const arr2 = new Uint8Array(buffer2)
        arr.set(arr2, arr1.byteLength)

        const blob = new Blob([arr.buffer])
        const url = URL.createObjectURL(blob)
        img.src = url

        const link = document.createElement('a')
        link.href = url
        link.download = 'image.jpg'
        document.body.appendChild(link)
        link.click()
        link.addEventListener('click', () => {
          link.remove()
        })
      })
    </script>
  </body>
</html>
```

[JavaScript 中如何实现大文件并行下载？](https://juejin.cn/post/6954868879034155022)、[基于 HTTP Range 实现文件分片并发下载！](https://juejin.cn/post/7219140831365857317)
