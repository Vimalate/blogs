---
title: 计算机与网络安全
date: 2023-04-03
tags:
 - 其他
 - 面试
 - http
categories: 
 - 面试
---
## 跨域

跨域：非同源策略请求
同源策略：浏览器的安全机制
源=协议+端口+域名 同源-三个都相等

## 从输入URL到页面加载发生了什么？

1. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
  **有缓存**

  如为强缓存，通过 ```Expires 和 Cache-control：max-age``` 来判断缓存是否过期，两者同时存在的的话，Cache-control：max-age 优先级更高

  >Cache-Control: no-cache 和no-store的区别：实际上Cache-Control: no-cache是会被缓存的，只不过浏览器每次都会向服务器发起请求，来验证当前缓存的有效性，Cache-Control: no-store：这个才是响应不被缓存的意思

  如为协商缓存，通过 if-none-match(Etag) 和 if-modified-since(last-modified) 验证缓存是否有效，若有效则返回状态码为 304，否则返回资源，返回状态码为 200
2. DNS 解析 URL 对应 ip
3. TCP 三次握手
4. HTTP 发起请求
5. 服务端处理请求，浏览器接受 HTTP 响应
6. 渲染页面，构建 dom 树
  ① 解析html 生成 DOM 树
  ②根据 css 解析生成 css树
  ③结合 DOM 树和 CSS 规则树，生成渲染树
  ④根据渲染树计算每一个节点的信息（layout布局）
  ⑤根据计算好的信息绘制页面

如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，如果有，异步去下载该资源；如果没有设置，暂停dom的解析，去加载script的资源，然后执行该js代码（script标签加载和执行会阻塞页面的渲染）
7. TCP 四次挥手，关闭连接

## TCP的三次握手和四次挥手

### 三次握手

1）第一次握手：客户端向服务端发送连接请求报文，请求发送后，客户端便进入 SYN-SENT 状态
2）第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，发送完成后便进入 SYN-RECEIVED 状态
3）第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED(已建立的) 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

**为什么需要三次握手**

确保服务端和客户端均让对方知道自己接受发送能力没问题而保证的最小次数，两次不安全，四次浪费资源

### 四次挥手

当服务端收到客户端关闭报文时，并不会立即关闭，先回复一个报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送连接释放请求，因此不能一起发送。故需要四步挥手
举例：
Browser:先告诉服务器 “我数据都发完了，你可以关闭连接了。”
Server:回复浏览器 “关闭的请求我收到了，我先看看我这边还有没有数据没传完。”
Server:确认过以后，再次回复浏览器 “我这边数据传输完成了，你可以关闭连接了。”
Browser:告诉服务器 “好的，那我关闭了。不用回复了。”
客户端又等了2MSL，确认确实没有再收到请求了，才会真的关闭TCP连接。

**为什么需要四次挥手？**
1）TCP 使用四次挥手的原因，是因为 TCP 的连接是全双工的，所以需要双方分别释放掉对方的连接
2）单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态
3）最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止客户端发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭
什么是2MSL？
MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”

**四次挥手后，为什么客户端最后还要等待2MSL？**
1）保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，如果服务端没有收到，服务端会重发一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器
2）防止“已经失效的连接请求报文段”出现在本连接中
客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的所产生的所有报文都从网络中消失。这样新的连接中不会出现旧连接的请求报文


## TCP和UDP的区别

相同点：  UDP协议和TCP协议都是传输层协议
不同点：

1）TCP 面向有连接； UDP：面向无连接
2）TCP 要提供可靠的、面向连接的传输服务。TCP在建立通信前，必须建立一个TCP连接，之后才能传输数据。TCP建立一个连接需要3次握手，断开连接需要4次挥手，并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端
3）UDP不可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地
4）应用场景
TCP效率要求相对低，但对准确性要求相对高的场景。如常见的接口调用、文件传输、远程登录等
UDP效率要求相对高，对准确性要求相对低的场景。如在线视频、网络语音电话等

## http1、2、3的区别



## 线程与进程

**进程可以包含多个线程**

进程是 CPU 资源分配的最小单位，线程是 CPU 调度的最小单位

## js 为什么设计成单线程

如果有多个线程，假如一个线程在 DOM 节点上添加内容，另一个线程删除了这个节点，那么就会造成冲突，我了避免冲突，所以决定了 js 为单线程的

### 浏览器线程包含

- 浏览器主线程

主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

1）GUI渲染线程
主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等
2）JS引擎线程
该线程主要负责处理 JavaScript 脚本，执行代码。该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。
3）事件触发线程
主要负责将准备好的事件交给 JS 引擎线程执行。比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行
4）定时器触发线程
负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval
5）异步http请求线程
负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等


- render 渲染进程

核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下

- GPU 进程

GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制

- 第三方插件进程

主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，每种类型的插件对应一个进程， 以保证插件进程崩溃不会对浏览器和页面造成影响。

## 垃圾回收机制



## 参考

[10万字前端知识体系总结（前端框架+浏览器原理篇）](https://juejin.cn/post/7146996646394462239)


