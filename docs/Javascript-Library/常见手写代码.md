---
title: 常见手写代码
date: 2020-05-22 01:30:31
tags:
 - javascript
categories: 
 - javascript
---
## 手写 new 的执行过程
首先我们知道 new 的执行过程如
1. 创建一个空对象
2. 将对象的 ```__proto__``` 指向构造函数的 prototype
3. 将这个对象作为构造函数的 this
4. 确保返回值为对象

```js
function myNew(Con,...arg) {
  let obj=Object.creat(Con.prototype)
  let result=Con.apply(obj,arg)
  return typeof result === 'object'?result:obj

}

```
## 编写javascript深度克隆函数
```js
  Object.prototype.clone = function() {
      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}
      for (let e in this) { //遍历对象的属性 in  this[e]
        newObject[e] = typeof this[e] === 'object' ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型
      }
      return newObject
    }
```
##  手写ajax
```js
function get(){
  //创建ajax实例
  let req=new XMLHTTPRequest();
  if(req){
    //执行open 确定要访问的链接 以及同步异步
    req.open("GET", "http://test.com/?keywords=手机", true);
    //监听请求状态
    req.onreadystatechange=function(){
      if(req.readystate===4){
        if(req.statue===200){
          console.log('success')
        }else{
          console.log('error')
        }
      }
    }
    //发送请求
    req.send()
  }
}
```

## 手写 instanceof
```js
function myInstanceof(left, right) {
  let prototype=right.prototype
  left=left.__proto__
  while(true){
    if(left===null||left===undefined){
      return false
    }
    if(prototype===left){
      return true
      left=left.__proto__
    }
  }
}
```


## 手写一个深度比较 isEqual

```js
function isEqual (obj1, obj2) {
	//不是对象,直接返回比较结果
	if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
		return obj1 === obj2
	}
	//都是对象,且地址相同,返回true
	if (obj2 === obj1) return true;
	//是对象或数组
	let keys1 = Object.keys(obj1)
	let keys2 = Object.keys(obj2)
	//比较keys的个数,若不同,肯定不相等
	if (keys1.length !== keys2.length) return false;
	for (let k of keys1) {
		//递归比较键值对
		let res = isEqual(obj1[k], obj2[k])
		if (!res) return false;
	}
	return true;
}

const obj1 = {
	a: 100,
	b: {
		x: 100,
		y: 200
	}
}
const obj2 = {
	a: 200,
	b: {
		x: 100,
		y: 200
	}
}
console.log(isEqual(obj1, obj2)) //false
```

## 手写深拷贝

```js
function deepClone (obj = {}) {
  if (typeof obj !== 'object' || obj == null) {
    // obj 是 null。或者不是对象或数组，直接返回
    return obj
  }
  // 初始化返回结果
  let result
  if (obj instanceof Array) {
    result = []
  } else {
    result = {}
  }
  for (const key in obj) {
    // 保证 key 不是原型的属性
    if (Object.hasOwnProperty.call(obj, key)) {
      // 递归调用
      result[key] = deepClone(obj[key])
    }
  }
  return result
}
```