(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{616:function(v,t,_){v.exports=_.p+"assets/img/soft-link&hard-link.e8fe5b17.png"},617:function(v,t,_){v.exports=_.p+"assets/img/pnpm.5ccb0d64.png"},815:function(v,t,_){"use strict";_.r(t);var a=_(2),s=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"什么是前端工程化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是前端工程化"}},[v._v("#")]),v._v(" 什么是前端工程化")]),v._v(" "),t("p",[v._v("前端工程化是指围绕代码处理的一系列工具链，他们把代码当作字符串处理，并不关心代码的内容，包括"),t("strong",[v._v("编译构建、静态分析、格式化、CI/CD")]),v._v("等等。")]),v._v(" "),t("h2",{attrs:{id:"软连接与硬连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软连接与硬连接"}},[v._v("#")]),v._v(" 软连接与硬连接")]),v._v(" "),t("p",[t("img",{attrs:{src:_(616),alt:""}})]),v._v(" "),t("h2",{attrs:{id:"pnpm-常用命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-常用命令"}},[v._v("#")]),v._v(" pnpm 常用命令")]),v._v(" "),t("p",[t("img",{attrs:{src:_(617),alt:""}})]),v._v(" "),t("h2",{attrs:{id:"组件封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件封装"}},[v._v("#")]),v._v(" 组件封装")]),v._v(" "),t("p",[t("strong",[v._v("组件封装原则：")])]),v._v(" "),t("p",[v._v("一个组件只专注做一件事，且把这件事做好（通用 易用 可组合）：")]),v._v(" "),t("ul",[t("li",[v._v("功能上拆分层次")]),v._v(" "),t("li",[v._v("尽量让组件原子化（便于使用者自己组合）")]),v._v(" "),t("li",[v._v("容器组件（只管理数据）&UI组件（只显示视图）")])]),v._v(" "),t("p",[t("strong",[v._v("针对于业务，尽量做到组件的原子化，而不是做大而全的组件，考虑后续的扩展性及维护成本以及使用者的心智负担")])]),v._v(" "),t("p",[t("strong",[v._v("vue组件三要素：")])]),v._v(" "),t("ol",[t("li",[v._v("props参数")]),v._v(" "),t("li",[v._v("slot定制插槽")]),v._v(" "),t("li",[v._v("event自定义事件")])]),v._v(" "),t("p",[t("strong",[v._v("组件封装思想：")])]),v._v(" "),t("ul",[t("li",[v._v("判断基本类型\n"),t("ul",[t("li",[v._v("哪些写死")]),v._v(" "),t("li",[v._v("哪些传进来")])])]),v._v(" "),t("li",[v._v("扩展\n"),t("ul",[t("li",[v._v("自定义事件，判断传出参数")]),v._v(" "),t("li",[v._v("插槽扩展")])])]),v._v(" "),t("li",[v._v("优化\n"),t("ul",[t("li",[v._v("提高适应性(v-if,v-show,component 动态组件)")])])])]),v._v(" "),t("p",[t("strong",[v._v("使用者的学习成本")])]),v._v(" "),t("ul",[t("li",[v._v("是否增加额外的心智负担")]),v._v(" "),t("li",[v._v("有无配套的使用文档及示例")])]),v._v(" "),t("h2",{attrs:{id:"解释一下ci-cd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释一下ci-cd"}},[v._v("#")]),v._v(" 解释一下CI/CD")]),v._v(" "),t("p",[t("strong",[v._v("持续集成和持续交付/部署")])]),v._v(" "),t("ul",[t("li",[v._v("持续集成：开发人员提交代码后，自动化构建，自动化测试和自动化部署。")]),v._v(" "),t("li",[v._v("持续交付/部署：经过持续集成的代码（经测试过，并通过了品质保证的软件代码），自动化的部署至生产环境中")])]),v._v(" "),t("p",[v._v("提高开发项目的质量，降低风险和加速交付时间，提高开发效率、质量和团队协作能力。")]),v._v(" "),t("h2",{attrs:{id:"了解-tree-shaking-吗-说说他的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#了解-tree-shaking-吗-说说他的实现原理"}},[v._v("#")]),v._v(" 了解 tree shaking 吗，说说他的实现原理")]),v._v(" "),t("p",[v._v("摇树优化（tree shaking）是一种能够将没有用到的代码在编译阶段自动去除的优化技术，主要目的是减小浏览器中加载 javascript 的代码体积，从而提高网站性能。")]),v._v(" "),t("p",[v._v("其实现原理主要是利用了es6模块化规范中的静态引用关系，即在静态分析阶段（不需要真正运行代码）就能知道一个模块是否被导出使用，javascript利用这些信息来剔除没被使用的代码，从而做到减小生成的 bundle 大小。")]),v._v(" "),t("p",[v._v("具体实现过程如下：")]),v._v(" "),t("ol",[t("li",[v._v("遍历源码中所有模块以及她们的导入关系，生成一张完整的依赖树")]),v._v(" "),t("li",[v._v("对于应用入口文件的依赖项进行分析，找出其中没有被用到的导出项")]),v._v(" "),t("li",[v._v("去除没有被用到的导出项")])]),v._v(" "),t("blockquote",[t("p",[v._v("需要注意的是，tree shaking 并不是完美的，它有一些限制。例如，如果一个模块导出的是一个对象或类，而这个对象或类的某些属性或方法被其他模块使用，那么整个对象或类都不会被 tree shaking 删除。因此，为了使 tree shaking 生效，我们需要尽可能地将模块拆分成更小的单元，并将不同的模块之间的依赖关系尽可能明确地声明出来。")])]),v._v(" "),t("h2",{attrs:{id:"babel是什么-能说说他的原理实现吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel是什么-能说说他的原理实现吗"}},[v._v("#")]),v._v(" Babel是什么？能说说他的原理实现吗")]),v._v(" "),t("p",[v._v("babel 是一个广泛使用的 Javascript 编译器，可以将 es6及以上的代码转换为向后兼容的代码。")]),v._v(" "),t("p",[v._v("原理实现：")]),v._v(" "),t("ol",[t("li",[v._v("解析：babel 会先使用插件将源代码解析为 ast")])]),v._v(" "),t("ul",[t("li",[v._v("词法分析：将源代码分解为 token(如变量名、运算符等)")]),v._v(" "),t("li",[v._v("语法分析：将词法分析产生的词法单元转化为AST")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("转换：遍历得到的 ast，对其进行修改和重构，包括添加、删除、替换、移动节点等操作")]),v._v(" "),t("li",[v._v("生成：将转换后的 ast 重新生成为代码")])]),v._v(" "),t("h2",{attrs:{id:"eslint-原理实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eslint-原理实现"}},[v._v("#")]),v._v(" eslint 原理实现")]),v._v(" "),t("p",[v._v("解析js生成token，词法分析，语法分析，再转化为抽象语法树ast，根据配置的rules，将AST与规则进行匹配，检查代码是否符合规范")]),v._v(" "),t("p",[v._v("ESLint 是一款可配置的 JavaScript 代码检测工具，可以帮助开发者保持代码风格的一致性，规避潜在的错误和代码质量问题。它的原理基于以下三个步骤：")]),v._v(" "),t("ol",[t("li",[v._v("代码解析：ESLint 使用 Esprima 将代码解析成一个抽象语法树（AST），以便进行后续的检测和修复。同时，还可以使用不同的解析器来支持不同的 JavaScript 语法。")]),v._v(" "),t("li",[v._v("规则匹配：ESLint 根据用户在配置文件中定义的规则，匹配检测代码中存在的问题，并生成一份问题清单。这些规则可以是官方的也可以是自定义的。其中，每个规则都是一个函数，用来检测 AST 中的节点是否符合规定的规则。")]),v._v(" "),t("li",[v._v("输出结果：ESLint 根据检测结果，生成一份报告，指出代码中的问题。这个报告可以在控制台输出，也可以配置输出到指定的文件中。")])]),v._v(" "),t("p",[v._v("在实现规则匹配时，ESLint 提供了一些钩子函数和 API，方便插件和规则的开发。并且还支持通过配置项对插件和规则进行启用和禁用、调整检测顺序等操作，可以更加灵活地适应各种项目的需求和场景。\n需要注意的是，ESLint 本身只是一个坚持规范和风格的工具，并不会自动修复代码问题。因此，开发者需要通过配合使用其他工具（如 Prettier、lint-staged 等）来对代码进行格式化和修复，以便提高开发效率和代码质量。")])])}),[],!1,null,null,null);t.default=s.exports}}]);